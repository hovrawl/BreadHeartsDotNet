// ***********************************************************************
// Assembly         : DomainObjects
// Author           : Grant Scanes
// Created          : 05-30-2018
//
// Last Modified By : Grant Scanes
// Last Modified On : 05-30-2018
// ***********************************************************************
// <copyright file="StringExtensions.cs" company="DomainObjects">
//     Copyright (c) inReachSW. All rights reserved.
// </copyright>
// <summary></summary>
// ***********************************************************************

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace CodeGenerators.Classes
{
    /// <summary>
    ///     Class StringExtensions.
    /// </summary>
    /// <autogeneratedoc />
    public static class StringExtensions
    {
        /// <summary>
        ///     Shortens the string.
        /// </summary>
        /// <param name="text">The text.</param>
        /// <param name="length">The length.</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        public static string ShortenString(this string text, int length)
        {
            if (text.Length <= length) return text;
            var pos = text.IndexOf(" ", length, StringComparison.Ordinal);
            if (pos >= 0)
                return text.Substring(0, pos) + "...";
            return text;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static string CleanSearchString(this string s)
        {
            if (string.IsNullOrEmpty(s)) return string.Empty;

            var charToRemove = new[] {'\''};

            var split = s.Split(charToRemove);
            var join = string.Join(string.Empty, split);
            return join.Trim();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="s"></param>
        /// <returns></returns>
        public static string CleanAscii(this string s)
        {
            // Get the bytes

            var bytes = Encoding.UTF8.GetBytes(s);

            // Set up a destination encoding scheme

            var encFallback = new EncoderReplacementFallback(string.Empty);
            var decFallback = new DecoderExceptionFallback();
            var dstEncoding = Encoding.GetEncoding(Encoding.ASCII.EncodingName, encFallback, decFallback);

            // Convert the bytes

            var convertedBytes = Encoding.Convert(Encoding.UTF8, dstEncoding, bytes);

            // Output the ascii only string

            var returnString = Encoding.ASCII.GetString(convertedBytes);

            returnString = returnString.Trim();
            return returnString;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="text"></param>
        /// <returns></returns>
        public static string Htmlinize(this string text)
        {
            if (string.IsNullOrEmpty(text)) return "";
            var n = new List<string>();
            n.AddRange(text.Split(new string[] { "\r\n", "\n" }, StringSplitOptions.None));
            return string.Join("<br />", n);
        }

        /// <summary>
        /// Truncates the specified length.
        /// </summary>
        /// <param name="value">The value.</param>
        /// <param name="length">The length.</param>
        /// <returns>System.String.</returns>
        /// <autogeneratedoc />
        public static string Truncate(this string value, int length)
        {
            if (value.Length <= length) return value;
            //var pos = value.IndexOf(" ", length, StringComparison.Ordinal);
            //if (pos >= 0)
            //    return value.Substring(0, pos) + "...";
            return value.Substring(0, length - 3) + "..."; ;
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public static string CalculateMD5Hash(this string input)

        {
            var md5 = System.Security.Cryptography.MD5.Create();
            var inputBytes = System.Text.Encoding.ASCII.GetBytes(input);
            var hash = md5.ComputeHash(inputBytes);
            return BitConverter.ToString(hash).Replace("-", "").ToLowerInvariant();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        public static string MakeSafe(this string input)
        {
            if(string.IsNullOrEmpty(input)) return "";
            var pattern = new Regex(@"[-|_=,!.&$'\(\)\[\]\{\} ]");
           
            return pattern.Replace(input, "").Replace(@"\","|");
        }

        public static string ToBase64(this string value)
        {
            var plainTextBytes = Encoding.UTF8.GetBytes(value);
            return Convert.ToBase64String(plainTextBytes).Replace("=", "repequalsrep");

        }

        public static string FromBase64(this string value)
        {
            var base64EncodedBytes = Convert.FromBase64String(value.Replace("repequalsrep", "="));
            return Encoding.UTF8.GetString(base64EncodedBytes);
        }

        public static string MakeDocSafeForInTouch(this string input)
        {
            if (string.IsNullOrEmpty(input)) return "";
            var pattern = new Regex(@"[-|_=,!&$ #]");
            return pattern.Replace(input, "").Replace(@"\", "|");

            //return input.Replace("|", "").Replace("_", "").Replace("=", "").Replace(",", "").Replace("!", "").Replace(".", "").Replace("-", "").Replace(" ", "");

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="target"></param>
        /// <returns></returns>
        public static int LevenshteinDistance(string source, string target)
        {
            // degenerate cases
            if (source == target) return 0;
            if (source.Length == 0) return target.Length;
            if (target.Length == 0) return source.Length;

            // create two work vectors of integer distances
            int[] v0 = new int[target.Length + 1];
            int[] v1 = new int[target.Length + 1];

            // initialize v0 (the previous row of distances)
            // this row is A[0][i]: edit distance for an empty s
            // the distance is just the number of characters to delete from t
            for (int i = 0; i < v0.Length; i++)
                v0[i] = i;

            for (int i = 0; i < source.Length; i++)
            {
                // calculate v1 (current row distances) from the previous row v0

                // first element of v1 is A[i+1][0]
                //   edit distance is delete (i+1) chars from s to match empty t
                v1[0] = i + 1;

                // use formula to fill in the rest of the row
                for (int j = 0; j < target.Length; j++)
                {
                    var cost = (source[i] == target[j]) ? 0 : 1;
                    v1[j + 1] = Math.Min(v1[j] + 1, Math.Min(v0[j + 1] + 1, v0[j] + cost));
                }

                // copy v1 (current row) to v0 (previous row) for next iteration
                for (int j = 0; j < v0.Length; j++)
                    v0[j] = v1[j];
            }

            return v1[target.Length];
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <param name="target"></param>
        /// <returns></returns>
        public static double CalculateSimilarity(this string source, string target)
        {
            if ((source == null) || (target == null)) return 0.0;
            if ((source.Length == 0) || (target.Length == 0)) return 0.0;
            if (source == target) return 1.0;

            var stepsToSame = LevenshteinDistance(source, target);
            return (1.0 - ((double) stepsToSame / (double) Math.Max(source.Length, target.Length)));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        /// <returns></returns>
        public static List<string> SplitSetting(this string source)
        {
            return source.Split(',', '|', ';').ToList();
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="source"></param>
        public static void ThrowWildCardCheck(this string source)
        {
            if (source.Equals("*") || source.Equals("?"))
            {
                throw new Exception("Please refine search criteria");
            }

            var hasQuestionMark = source.Contains("?");
            var hasStar = source.Contains("*");
            if (hasStar && hasQuestionMark)
            {
                throw new Exception("Search cannot contain both '*' and '?' characters");
            }
        }


        /// <summary>
        /// Splits the value list.
        /// </summary>
        /// <param name="source">The source.</param>
        /// <returns>List&lt;System.String&gt;.</returns>
        public static List<string> SplitValueList(this string source)
        {
            return source.Split(',', '|', ';').ToList();
        }
    }
}

  